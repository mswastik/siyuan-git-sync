/**
 * SiYuan Git Sync Plugin
 * Syncs your workspace with GitHub - preserves file structure and syncs .sy files directly
 */

import { Plugin, showMessage, Menu } from "siyuan";
import { SettingUtils } from "./libs/setting-utils";

const STORAGE_NAME = "git-sync-config";

interface GitConfig {
    repoOwner: string;
    repoName: string;
    branch: string;
    token: string;
    authorName: string;
    authorEmail: string;
    autoSync: boolean;
    syncInterval: number;
}

interface GitHubTreeItem {
    path: string;
    mode: string;
    type: string;
    sha?: string;
    size?: number;
    url?: string;
}

interface LocalFile {
    path: string;
    content: string;
    isNew: boolean;
}

export default class GitSyncPlugin extends Plugin {
    private config: GitConfig = {
        repoOwner: "",
        repoName: "",
        branch: "main",
        token: "",
        authorName: "SiYuan User",
        authorEmail: "user@siyuan.local",
        autoSync: false,
        syncInterval: 30
    };
    
    private topBarElement: HTMLElement;
    private syncIntervalId: number | null = null;
    private isSyncing = false;
    private settingUtils: SettingUtils;

    async onload() {
        console.log("Loading Git Sync Plugin");
        
        this.settingUtils = new SettingUtils({
            plugin: this,
            name: STORAGE_NAME
        });
        
        this.registerSettings();
        await this.loadConfig();
        this.addTopBarIcon();

        if (this.config.autoSync && this.isConfigValid()) {
            this.startAutoSync();
        }

        showMessage("‚úÖ Git Sync Plugin Loaded", 2000, "info");
    }

    onunload() {
        console.log("Unloading Git Sync Plugin");
        this.stopAutoSync();
    }

    onLayoutReady() {
        console.log("Layout ready for Git Sync Plugin");
    }

    private async loadConfig() {
        try {
            const savedConfig = await this.loadData(STORAGE_NAME);
            if (savedConfig) {
                const parsed = typeof savedConfig === 'string' 
                    ? JSON.parse(savedConfig) 
                    : savedConfig;
                this.config = { ...this.config, ...parsed };
                console.log("Config loaded successfully");
            }
        } catch (e) {
            console.error("Failed to load config:", e);
        }
    }

    private async saveConfig() {
        await this.saveData(STORAGE_NAME, JSON.stringify(this.config, null, 2));
        
        if (this.config.autoSync && this.isConfigValid()) {
            this.startAutoSync();
        } else {
            this.stopAutoSync();
        }
        
        showMessage("‚úÖ Configuration saved", 2000, "info");
    }

    private addTopBarIcon() {
        this.topBarElement = this.addTopBar({
            icon: "iconCloud",
            title: "Git Sync",
            position: "right",
            callback: () => {
                this.showMenu();
            }
        });
    }

    private isConfigValid(): boolean {
        return !!(
            this.config.repoOwner &&
            this.config.repoName &&
            this.config.branch &&
            this.config.token
        );
    }

    private showError(message: string, error?: any) {
        console.error(message, error);
        let errorMsg = `‚ùå ${message}`;
        if (error?.message) {
            errorMsg += `\n${error.message}`;
        }
        showMessage(errorMsg, 6000, "error");
    }

    private async githubRequest(endpoint: string, method: string = "GET", body?: any): Promise<any> {
        const url = `https://api.github.com${endpoint}`;
        const headers: Record<string, string> = {
            "Authorization": `Bearer ${this.config.token}`,
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json",
            "User-Agent": "SiYuan-Git-Sync-Plugin"
        };

        const options: RequestInit = { method, headers };
        if (body) {
            options.body = JSON.stringify(body);
        }

        try {
            const response = await fetch(url, options);
            
            if (!response.ok) {
                const errorText = await response.text();
                let errorMsg = `GitHub API Error (${response.status})`;
                
                if (response.status === 401) {
                    errorMsg += ": Invalid token";
                } else if (response.status === 403) {
                    errorMsg += ": Access forbidden";
                } else if (response.status === 404) {
                    errorMsg += ": Not found";
                } else {
                    errorMsg += `: ${errorText}`;
                }
                
                throw new Error(errorMsg);
            }

            if (response.status === 204) return null;
            return await response.json();
        } catch (error: any) {
            if (error.message.includes("Failed to fetch")) {
                throw new Error("Network error - check your internet connection");
            }
            throw error;
        }
    }

    private async testConnection() {
        if (!this.isConfigValid()) {
            showMessage("‚ö†Ô∏è Please configure all required settings first", 3000, "error");
            return;
        }

        showMessage("üîç Testing connection...", 2000, "info");

        try {
            const repo = await this.githubRequest(
                `/repos/${this.config.repoOwner}/${this.config.repoName}`
            );
            showMessage(`‚úÖ Connected to: ${repo.full_name}`, 3000, "info");
        } catch (error) {
            this.showError("Connection test failed", error);
        }
    }

    private async getGitHubTree(sha?: string): Promise<GitHubTreeItem[]> {
        try {
            let treeSha = sha;
            
            if (!treeSha) {
                try {
                    const ref = await this.githubRequest(
                        `/repos/${this.config.repoOwner}/${this.config.repoName}/git/refs/heads/${this.config.branch}`
                    );
                    const commit = await this.githubRequest(ref.object.url.replace('https://api.github.com', ''));
                    treeSha = commit.tree.sha;
                } catch (error: any) {
                    // Branch might not exist or have no commits yet
                    if (error.message.includes("404")) {
                        console.log("Branch not found or empty, returning empty tree");
                        return [];
                    }
                    throw error;
                }
            }

            // Check if it's the empty tree SHA
            if (treeSha === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {
                console.log("Empty tree detected, returning empty array");
                return [];
            }

            const tree = await this.githubRequest(
                `/repos/${this.config.repoOwner}/${this.config.repoName}/git/trees/${treeSha}?recursive=1`
            );
            
            return tree.tree || [];
        } catch (error: any) {
            if (error.message.includes("404") || error.message.includes("Not Found")) {
                console.log("Tree not found, returning empty array");
                return [];
            }
            throw error;
        }
    }

    private async getFileContent(path: string): Promise<{ content: string; sha: string } | null> {
        try {
            const data = await this.githubRequest(
                `/repos/${this.config.repoOwner}/${this.config.repoName}/contents/${encodeURIComponent(path)}?ref=${this.config.branch}`
            );
            
            if (data.type === "file" && data.content) {
                return {
                    content: atob(data.content.replace(/\n/g, '')),
                    sha: data.sha
                };
            }
        } catch (error: any) {
            if (error.message.includes("404")) {
                return null;
            }
            throw error;
        }
        return null;
    }

    private async readLocalFile(path: string): Promise<string | null> {
        try {
            const response = await fetch("/api/file/getFile", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ path })
            });
            
            if (!response.ok) {
                console.error(`HTTP error reading ${path}: ${response.status} ${response.statusText}`);
                return null;
            }
            
            const data = await response.json();
            console.log(`Read file response for ${path}:`, data);
            
            if (data.code === 0) {
                // The data might be base64 encoded or plain text
                if (data.data !== undefined) {
                    if (typeof data.data === 'string') {
                        // Check if it's base64 encoded - typical base64 strings contain A-Z, a-z, 0-9, +, / characters
                        // and often end with =, == or no padding
                        const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                        if (base64Regex.test(data.data)) {
                            try {
                                // Decode base64 and convert to UTF-8 string
                                return atob(data.data);
                            } catch (decodeError) {
                                // If base64 decoding fails, return as-is
                                return data.data;
                            }
                        } else {
                            // It's likely already a plain text string
                            return data.data;
                        }
                    } else {
                        // If data.data is not a string, convert it to string
                        return String(data.data);
                    }
                } else {
                    console.warn(`No data returned for file: ${path}`);
                    return null;
                }
            } else {
                // Handle case where msg might not exist
                const errorMessage = data.msg || data.message || 'Unknown error' || JSON.stringify(data);
                console.error(`API error reading ${path}: ${errorMessage}`);
            }
        } catch (error) {
            console.error(`Failed to read local file ${path}:`, error);
        }
        return null;
    }

    private async writeLocalFile(path: string, content: string): Promise<boolean> {
        try {
            const response = await fetch("/api/file/putFile", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    path,
                    file: btoa(content),
                    isDir: false
                })
            });
            const data = await response.json();
            return data.code === 0;
        } catch (error) {
            console.error(`Failed to write local file ${path}:`, error);
            return false;
        }
    }

    private async listNotebooks(): Promise<any[]> {
        try {
            const response = await fetch("/api/notebook/lsNotebooks", {
                method: "POST"
            });
            const data = await response.json();
            return data.data?.notebooks || [];
        } catch (error) {
            console.error("Failed to list notebooks:", error);
            return [];
        }
    }

    private async listFiles(notebookId: string, path: string = "/"): Promise<any[]> {
        try {
            const dirPath = `/data/${notebookId}${path}`;
            console.log(`Listing files in: ${dirPath}`);
            
            const response = await fetch("/api/file/readDir", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    path: dirPath
                })
            });
            
            if (!response.ok) {
                console.error(`HTTP error listing directory ${dirPath}: ${response.status} ${response.statusText}`);
                return [];
            }
            
            const data = await response.json();
            console.log(`readDir response for ${dirPath}:`, data);
            
            if (data.code !== 0) {
                const errorMessage = data.msg || data.message || 'Unknown error';
                console.error(`Failed to read directory ${dirPath}:`, errorMessage);
                return [];
            }
            
            let allFiles: any[] = [];
            
            for (const item of data.data || []) {
                const itemPath = path === "/" ? `/${item.name}` : `${path}/${item.name}`;
                
                if (item.isDir) {
                    const subFiles = await this.listFiles(notebookId, itemPath);
                    allFiles = allFiles.concat(subFiles);
                } else if (item.name.endsWith('.sy')) {
                    allFiles.push({
                        name: item.name,
                        path: itemPath,
                        fullPath: `/data/${notebookId}${itemPath}`
                    });
                }
            }
            
            return allFiles;
        } catch (error) {
            console.error(`Failed to list files in ${notebookId}${path}:`, error);
            return [];
        }
    }

    private async getLocalFiles(): Promise<Map<string, string>> {
        const fileMap = new Map<string, string>();
        const notebooks = await this.listNotebooks();
        
        console.log(`Found ${notebooks.length} notebooks`);
        
        for (const notebook of notebooks) {
            console.log(`Processing notebook: ${notebook.name} (${notebook.id})`);
            const files = await this.listFiles(notebook.id);
            console.log(`  Found ${files.length} .sy files`);
            
            for (const file of files) {
                const content = await this.readLocalFile(file.fullPath);
                if (content !== null) {
                    const relativePath = `${notebook.name}${file.path}`;
                    fileMap.set(relativePath, content);
                    console.log(`  Added: ${relativePath}`);
                }
            }
        }
        
        console.log(`Total files to sync: ${fileMap.size}`);
        return fileMap;
    }

    private async createOrUpdateFile(path: string, content: string, sha?: string): Promise<void> {
        const message = sha 
            ? `Update ${path}`
            : `Create ${path}`;
        
        const body: any = {
            message: `${message} - ${new Date().toLocaleString()}`,
            content: btoa(unescape(encodeURIComponent(content))),
            branch: this.config.branch,
            committer: {
                name: this.config.authorName,
                email: this.config.authorEmail
            },
            author: {
                name: this.config.authorName,
                email: this.config.authorEmail
            }
        };

        if (sha) {
            body.sha = sha;
        }

        await this.githubRequest(
            `/repos/${this.config.repoOwner}/${this.config.repoName}/contents/${encodeURIComponent(path)}`,
            "PUT",
            body
        );
    }

    private async pushToGitHub() {
        if (!this.isConfigValid()) {
            showMessage("‚ö†Ô∏è Please configure settings first", 3000, "error");
            return;
        }

        if (this.isSyncing) {
            showMessage("‚è≥ Sync already in progress", 2000, "info");
            return;
        }

        this.isSyncing = true;
        showMessage("üì§ Pushing to GitHub...", 3000, "info");

        try {
            const localFiles = await this.getLocalFiles();
            const githubTree = await this.getGitHubTree();
            
            const githubFiles = new Map<string, GitHubTreeItem>();
            for (const item of githubTree) {
                if (item.type === "blob") {
                    githubFiles.set(item.path, item);
                }
            }

            let uploaded = 0;
            let updated = 0;
            let skipped = 0;
            let errors = 0;

            for (const [path, content] of localFiles) {
                try {
                    const githubFile = githubFiles.get(path);
                    
                    if (githubFile) {
                        const remoteFile = await this.getFileContent(path);
                        if (remoteFile && remoteFile.content === content) {
                            skipped++;
                            continue;
                        }
                        await this.createOrUpdateFile(path, content, remoteFile?.sha);
                        updated++;
                    } else {
                        await this.createOrUpdateFile(path, content);
                        uploaded++;
                    }
                } catch (error) {
                    console.error(`Failed to sync ${path}:`, error);
                    errors++;
                }
            }

            const message = `‚úÖ Push complete\n` +
                `üì§ Uploaded: ${uploaded}\n` +
                `üîÑ Updated: ${updated}\n` +
                `‚è≠Ô∏è Skipped: ${skipped}` +
                (errors > 0 ? `\n‚ùå Errors: ${errors}` : '');
            
            showMessage(message, 5000, "info");
        } catch (error) {
            this.showError("Push failed", error);
        } finally {
            this.isSyncing = false;
        }
    }

    private async pullFromGitHub() {
        if (!this.isConfigValid()) {
            showMessage("‚ö†Ô∏è Please configure settings first", 3000, "error");
            return;
        }

        if (this.isSyncing) {
            showMessage("‚è≥ Sync already in progress", 2000, "info");
            return;
        }

        this.isSyncing = true;
        showMessage("üì• Pulling from GitHub...", 3000, "info");

        try {
            const githubTree = await this.getGitHubTree();
            const notebooks = await this.listNotebooks();
            const notebookMap = new Map(notebooks.map((nb: any) => [nb.name, nb]));

            let created = 0;
            let updated = 0;
            let skipped = 0;
            let errors = 0;

            for (const item of githubTree) {
                if (item.type !== "blob" || !item.path.endsWith('.sy')) {
                    continue;
                }

                try {
                    const parts = item.path.split('/');
                    const notebookName = parts[0];
                    const relativePath = '/' + parts.slice(1).join('/');

                    let notebook = notebookMap.get(notebookName);
                    if (!notebook) {
                        const response = await fetch("/api/notebook/createNotebook", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ name: notebookName })
                        });
                        const data = await response.json();
                        if (data.code === 0) {
                            notebook = data.data.notebook;
                            notebookMap.set(notebookName, notebook);
                        } else {
                            errors++;
                            continue;
                        }
                    }

                    const localPath = `/data/${notebook.id}${relativePath}`;
                    const remoteFile = await this.getFileContent(item.path);
                    
                    if (!remoteFile) {
                        errors++;
                        continue;
                    }

                    const localContent = await this.readLocalFile(localPath);
                    
                    if (localContent === remoteFile.content) {
                        skipped++;
                        continue;
                    }

                    const success = await this.writeLocalFile(localPath, remoteFile.content);
                    if (success) {
                        if (localContent === null) {
                            created++;
                        } else {
                            updated++;
                        }
                    } else {
                        errors++;
                    }
                } catch (error) {
                    console.error(`Failed to sync ${item.path}:`, error);
                    errors++;
                }
            }

            const message = `‚úÖ Pull complete\n` +
                `üì• Created: ${created}\n` +
                `üîÑ Updated: ${updated}\n` +
                `‚è≠Ô∏è Skipped: ${skipped}` +
                (errors > 0 ? `\n‚ùå Errors: ${errors}` : '');
            
            showMessage(message, 5000, "info");
            
            // Reload workspace to show new files
            if (created > 0 || updated > 0) {
                await fetch("/api/filetree/refreshFiletree", { method: "POST" });
            }
        } catch (error) {
            this.showError("Pull failed", error);
        } finally {
            this.isSyncing = false;
        }
    }

    private async fullSync() {
        if (!this.isConfigValid()) {
            showMessage("‚ö†Ô∏è Please configure settings first", 3000, "error");
            return;
        }
        
        if (this.isSyncing) {
            showMessage("‚è≥ Sync already in progress", 2000, "info");
            return;
        }

        showMessage("üîÑ Starting full sync...", 3000, "info");
        this.isSyncing = true;

        try {
            // Pull first to get remote changes
            await this.pullFromGitHubInternal();
            
            // Small delay to ensure files are written
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Then push local changes
            await this.pushToGitHubInternal();
            
            showMessage("‚úÖ Full sync completed", 3000, "info");
        } catch (error) {
            this.showError("Full sync failed", error);
        } finally {
            this.isSyncing = false;
        }
    }

    // Internal methods that don't set isSyncing flag
    private async pullFromGitHubInternal() {
        const githubTree = await this.getGitHubTree();
        const notebooks = await this.listNotebooks();
        const notebookMap = new Map(notebooks.map((nb: any) => [nb.name, nb]));

        let totalProcessed = 0;

        for (const item of githubTree) {
            if (item.type !== "blob" || !item.path.endsWith('.sy')) continue;

            const parts = item.path.split('/');
            const notebookName = parts[0];
            const relativePath = '/' + parts.slice(1).join('/');

            let notebook = notebookMap.get(notebookName);
            if (!notebook) {
                const response = await fetch("/api/notebook/createNotebook", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ name: notebookName })
                });
                const data = await response.json();
                if (data.code === 0) {
                    notebook = data.data.notebook;
                    notebookMap.set(notebookName, notebook);
                }
            }

            if (notebook) {
                const localPath = `/data/${notebook.id}${relativePath}`;
                const remoteFile = await this.getFileContent(item.path);
                
                if (remoteFile) {
                    const localContent = await this.readLocalFile(localPath);
                    if (localContent !== remoteFile.content) {
                        await this.writeLocalFile(localPath, remoteFile.content);
                        totalProcessed++;
                    }
                }
            }
        }

        if (totalProcessed > 0) {
            await fetch("/api/filetree/refreshFiletree", { method: "POST" });
        }
    }

    private async pushToGitHubInternal() {
        const localFiles = await this.getLocalFiles();
        const githubTree = await this.getGitHubTree();
        
        const githubFiles = new Map<string, GitHubTreeItem>();
        for (const item of githubTree) {
            if (item.type === "blob") {
                githubFiles.set(item.path, item);
            }
        }

        let totalProcessed = 0;

        for (const [path, content] of localFiles) {
            const githubFile = githubFiles.get(path);
            
            if (githubFile) {
                const remoteFile = await this.getFileContent(path);
                if (!remoteFile || remoteFile.content !== content) {
                    await this.createOrUpdateFile(path, content, remoteFile?.sha);
                    totalProcessed++;
                }
            } else {
                await this.createOrUpdateFile(path, content);
                totalProcessed++;
            }
        }
    }

    private async showStatus() {
        if (!this.isConfigValid()) {
            showMessage("‚ö†Ô∏è Please configure settings first", 3000, "error");
            return;
        }

        showMessage("üìä Checking status...", 2000, "info");

        try {
            const localFiles = await this.getLocalFiles();
            const githubTree = await this.getGitHubTree();
            const githubSyFiles = githubTree.filter(item => 
                item.type === "blob" && item.path.endsWith('.sy')
            );

            const notebooks = await this.listNotebooks();
            
            const statusMsg = `üìä Status:\n\n` +
                `üìö Local notebooks: ${notebooks.length}\n` +
                `üìÑ Local files: ${localFiles.size}\n` +
                `‚òÅÔ∏è GitHub files: ${githubSyFiles.length}\n` +
                `üîó Repository: ${this.config.repoOwner}/${this.config.repoName}\n` +
                `üåø Branch: ${this.config.branch}`;

            showMessage(statusMsg, 8000, "info");
        } catch (error) {
            this.showError("Failed to get status", error);
        }
    }

    private startAutoSync() {
        this.stopAutoSync();

        const intervalMs = Math.max(this.config.syncInterval, 5) * 60 * 1000;

        this.syncIntervalId = window.setInterval(async () => {
            if (!this.isSyncing && this.isConfigValid()) {
                console.log("‚è∞ Auto-sync triggered");
                await this.fullSync();
            }
        }, intervalMs);

        console.log(`‚úÖ Auto-sync started: every ${this.config.syncInterval} minutes`);
    }

    private stopAutoSync() {
        if (this.syncIntervalId) {
            clearInterval(this.syncIntervalId);
            this.syncIntervalId = null;
        }
    }

    private registerSettings() {
        this.settingUtils.addItem({
            key: "repoOwner",
            value: this.config.repoOwner,
            type: "textinput",
            title: "Repository Owner",
            description: "GitHub username or organization (e.g., 'octocat')",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("repoOwner");
                    if (value !== undefined) {
                        this.config.repoOwner = String(value).trim();
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "repoName",
            value: this.config.repoName,
            type: "textinput",
            title: "Repository Name",
            description: "Repository name (e.g., 'my-notes')",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("repoName");
                    if (value !== undefined) {
                        this.config.repoName = String(value).trim();
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "branch",
            value: this.config.branch,
            type: "textinput",
            title: "Branch",
            description: "Git branch (default: main)",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("branch");
                    if (value !== undefined) {
                        this.config.branch = String(value).trim() || "main";
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "token",
            value: this.config.token,
            type: "textinput",
            title: "GitHub Token",
            description: "Personal Access Token with 'repo' permissions",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("token");
                    if (value !== undefined) {
                        this.config.token = String(value).trim();
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "authorName",
            value: this.config.authorName,
            type: "textinput",
            title: "Author Name",
            description: "Name for Git commits",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("authorName");
                    if (value !== undefined) {
                        this.config.authorName = String(value);
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "authorEmail",
            value: this.config.authorEmail,
            type: "textinput",
            title: "Author Email",
            description: "Email for Git commits",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("authorEmail");
                    if (value !== undefined) {
                        this.config.authorEmail = String(value);
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "autoSync",
            value: this.config.autoSync,
            type: "checkbox",
            title: "Enable Auto-Sync",
            description: "Automatically sync at intervals",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("autoSync");
                    if (value !== undefined) {
                        this.config.autoSync = Boolean(value);
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "syncInterval",
            value: this.config.syncInterval,
            type: "number",
            title: "Sync Interval (minutes)",
            description: "Minutes between syncs (min 5)",
            action: {
                callback: () => {
                    const value = this.settingUtils.take("syncInterval");
                    if (value !== undefined) {
                        this.config.syncInterval = Math.max(5, Number(value));
                        this.saveConfig();
                    }
                }
            }
        });

        this.settingUtils.addItem({
            key: "testButton",
            value: "",
            type: "button",
            title: "Test Connection",
            description: "Test GitHub connection",
            button: {
                label: "üîç Test",
                callback: () => {
                    this.testConnection();
                }
            }
        });

        try {
            this.settingUtils.load();
        } catch (error) {
            console.error("Error loading settings:", error);
        }
    }

    async openSetting() {
        const settingPanel = this.setting;
        if (settingPanel) {
            settingPanel.open(STORAGE_NAME);
        }
    }
    
    private showMenu() {
        const menu = new Menu("gitSyncMenu");
        
        menu.addItem({
            icon: "iconSettings",
            label: "‚öôÔ∏è Settings",
            click: () => {
                this.openSetting();
            }
        });
        
        menu.addSeparator();
        
        menu.addItem({
            icon: "iconRefresh",
            label: "üîÑ Full Sync",
            click: () => {
                this.fullSync();
            }
        });
        
        menu.addItem({
            icon: "iconDownload",
            label: "üì• Pull from GitHub",
            click: () => {
                this.pullFromGitHub();
            }
        });
        
        menu.addItem({
            icon: "iconUpload",
            label: "üì§ Push to GitHub",
            click: () => {
                this.pushToGitHub();
            }
        });
        
        menu.addSeparator();
        
        menu.addItem({
            icon: "iconInfo",
            label: "üìä Status",
            click: () => {
                this.showStatus();
            }
        });
        
        menu.addItem({
            icon: "iconTest",
            label: "üîç Test Connection",
            click: () => {
                this.testConnection();
            }
        });
        
        const rect = this.topBarElement.getBoundingClientRect();
        menu.open({
            x: rect.left,
            y: rect.bottom,
            isLeft: true
        });
    }
}